// SPDX-License-Identifier: MPL-2.0
namespace Emik.SourceGenerators.Tattoo;

/// <summary>Creates global imports of every namespace of the current project.</summary>
[Generator]
public sealed class NamespaceGenerator : ISourceGenerator
{
    const string
        FileName = "GlobalUsings.g.cs",
        Global = "global::";

    static readonly AssemblyName s_name = typeof(NamespaceGenerator).Assembly.GetName();

    static readonly string s_header =
        $"// <auto-generated/>\n// {s_name.Name}, {s_name.Version.ToShortString()}\n#pragma warning disable\n";

    /// <inheritdoc />
    void ISourceGenerator.Execute(GeneratorExecutionContext context)
    {
        if (TryGenerate(context.Compilation, out var path, out var contents))
            File.WriteAllText(path, contents);
    }

    /// <inheritdoc />
    void ISourceGenerator.Initialize(GeneratorInitializationContext context) { }

    [MustUseReturnValue]
    static bool HasProjectFile(string x) => Directory.EnumerateFiles(x).Any(x => x.EndsWith(".csproj"));

    [Pure]
    static bool IsOther(SyntaxTree x) =>
        x.FilePath.AsSpan() is var span &&
        (span.LastIndexOfAny('/', '\\') is var index and not -1 ? span[++index..] : span) is not FileName;

    static bool FindProjectDirectory(
        [InstantHandle] in IEnumerable<SyntaxTree> trees,
        [NotNullWhen(true)] out string? path
    ) =>
        (path = trees
           .SelectMany(DirectoryNames)
           .Distinct(StringComparer.Ordinal)
           .FirstOrDefault(HasProjectFile)) is not null;

    // ReSharper disable PossibleMultipleEnumeration
    static bool TryGenerate(
        in Compilation compilation,
        [NotNullWhen(true)] out string? path,
        [NotNullWhen(true)] out string? contents
    ) =>
        ((path, contents) = (null, null)) is var _ &&
        compilation.SyntaxTrees is var trees &&
        trees.All(IsOther) &&
        FindProjectDirectory(trees, out var directory) &&
        ((path, contents) = (Path.Combine(directory, FileName), Imports(compilation))) is var _;

    [Pure]
    static IEnumerable<string> DirectoryNames(SyntaxTree x) =>
        Path.GetDirectoryName(x.FilePath).FindSmallPathToNull(Path.GetDirectoryName);

    [MustUseReturnValue] // ReSharper restore PossibleMultipleEnumeration
    static string Imports(in Compilation compilation)
    {
        StringBuilder sb = new(s_header);

        compilation
           .References
           .Select(compilation.GetAssemblyOrModuleSymbol)
           .Select(x => (x as IModuleSymbol)?.ContainingAssembly ?? x)
           .OfType<IAssemblySymbol>()
           .Filter()
           .SelectMany(x => x.GetAllMembers())
           .OfType<INamespaceSymbol>()
           .Concat(compilation.GetSymbolsWithName(_ => true, SymbolFilter.Namespace))
           .Select(x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
           .Distinct(StringComparer.Ordinal)
           .Omit(string.IsNullOrWhiteSpace)
           .Omit(x => x.Contains('<') || x.Contains('>'))
           .OrderByDescending(x => x.StartsWith($"{Global}{nameof(System)}"))
           .ThenBy(x => x, StringComparer.Ordinal)
           .For(x => sb.Append("global using ").Append(x).Append(";\n"))
           .Peek(_ => sb.Append("\n// Polyfills of namespaces in case dependencies are conditional.\n"))
           .For(x => sb.Append("namespace ").Append(x.StartsWith(Global) ? x[Global.Length..] : x).Append(" { }\n\n"));

        return $"{sb.Remove(^1..)}";
    }
}
